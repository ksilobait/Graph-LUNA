<!DOCTYPE html>
<!--suppress JSPotentiallyInvalidConstructorUsage -->
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Toolbar example for mxGraph</title>

	<!-- Sets the basepath for the library if not in same directory -->
	<script type="text/javascript">
		mxBasePath = '../src'
	</script>

	<!-- Loads and initializes the library -->
	<script type="text/javascript" src="../src/js/mxClient.js"></script>

	<!-- Example code -->
	<script type="text/javascript">
		// Program starts here. Creates a sample graph in the DOM node with the specified ID.
		// This function is invoked from the onLoad event handler of the document (see below).
		function main () {
			// Checks if browser is supported
			if (!mxClient.isBrowserSupported()) {
				// Displays an error message if the browser is not supported.
				mxUtils.error('Browser is not supported!', 200, false)
			} else {
				// Note that these XML nodes will be enclosing the mxCell nodes for the model cells in the output
				const xmlDocument = mxUtils.createXmlDocument()

				// Defines an icon for creating new connections in the connection handler.
				// This will automatically disable the highlighting of the source vertex.
				mxConnectionHandler.prototype.connectImage = new mxImage('images/connector.gif', 16, 16)

				// Creates the div for the toolbar
				const toolbarContainer = document.createElement('div')
				toolbarContainer.style.position = 'absolute'
				toolbarContainer.style.overflow = 'hidden'
				toolbarContainer.style.padding = '2px'
				toolbarContainer.style.left = '0px'
				toolbarContainer.style.top = '0px'
				toolbarContainer.style.width = '24px'
				toolbarContainer.style.bottom = '0px'
				document.body.appendChild(toolbarContainer)

				// Creates new toolbar without event processing
				const toolbar = new mxToolbar(toolbarContainer)
				toolbar.enabled = false

				// Creates the div for the graph
				const container = document.createElement('div')
				container.style.position = 'absolute'
				container.style.overflow = 'hidden'
				container.style.left = '24px'
				container.style.top = '0px'
				container.style.right = '0px'
				container.style.bottom = '0px'
				container.style.background = 'url("editors/images/grid.gif")'
				document.body.appendChild(container)

				// Workaround for Internet Explorer ignoring certain styles
				if (mxClient.IS_QUIRKS) {
					document.body.style.overflow = 'hidden'
					new mxDivResizer(toolbarContainer)
					new mxDivResizer(container)
				}

				// Creates the graph inside the given container
				const graph = new mxGraph(container)
				graph.setConnectable(true)
				graph.setMultigraph(false)
				graph.setCellsDisconnectable(false)
				graph.setAllowDanglingEdges(false)

				graph.multiplicities.push(new mxMultiplicity(
					false, 'Variable', null, null, 0, 1, ['Operation'],
					'Variable should be immutable', null))

				graph.multiplicities.push(new mxMultiplicity(
					true, 'Variable', null, null, 0, 0, ['Variable'],
					'You cannot variables to variables', null))

				graph.multiplicities.push(new mxMultiplicity(
					true, 'Operation', null, null, 0, 0, ['Operation'],
					'You cannot operations to operations', null))

				// Enables rubberband selection
				const rubberband = new mxRubberband(graph)

				// Removes cells when [DELETE] is pressed
				const keyHandler = new mxKeyHandler(graph)
				keyHandler.bindKey(46, function (event) {
					if (graph.isEnabled()) {
						graph.removeCells()
					}
				})

				// Overrides method to provide a cell label in the display
				graph.convertValueToString = function (cell) {
					if (mxUtils.isNode(cell.value)) {
						//if (cell.value.nodeName.toLowerCase() === 'variable')
						return cell.getAttribute('name', '')
					}
				}

				// Overrides method to store a cell label in the model
				const cellLabelChanged = graph.cellLabelChanged
				graph.cellLabelChanged = function (cell, newValue, autoSize) {
					if (mxUtils.isNode(cell.value)) {
						//if (cell.value.nodeName.toLowerCase() === 'person')
						// Clones the value for correct undo/redo
						const elt = cell.value.cloneNode(true)
						elt.setAttribute('name', newValue)
						newValue = elt
					}
					cellLabelChanged.apply(this, arguments)
				}

				// Shows a "modal" window when double clicking a vertex. TODO
				/*graph.dblClick = function (event, cell) {
					// Do not fire a DOUBLE_CLICK event here as mxEditor will
					// consume the event and start the in-place editor.
					if (this.isEnabled() &&	!mxEvent.isConsumed(event) &&
						cell != null &&	this.isCellEditable(cell)) {
						if (this.model.isEdge(cell)) {
							this.startEditingAtCell(cell)
						} else {
							var content = document.createElement('div')

							// Creates the form from the attributes of the user object
							var form = new mxForm()
							var attrs = cell.value.attributes
							for (var i = 0; i < attrs.length; i++) {
								createTextField(graph, form, cell, attrs[i])
							}
							content.appendChild(form.getTable())
							showModalWindow(this, 'Properties', content, 400, 300)
						}
					}

					// Disables any default behaviour for the double click
					mxEvent.consume(event)
				}*/

				// Add toolbar items
				const addVertex = function (icon, w, h, style) {
					//const vertex = new mxCell(null, new mxGeometry(0, 0, w, h), style)
					//vertex.setVertex(true)
					const img = addToolbarItem(graph, toolbar, w, h, style, icon, xmlDocument)
					img.enabled = true

					graph.getSelectionModel().addListener(mxEvent.CHANGE, function () {
						const tmp = graph.isSelectionEmpty()
						mxUtils.setOpacity(img, (tmp) ? 100 : 20)
						img.enabled = tmp
					})
				}

				addVertex('editors/images/rectangle.gif', 100, 40, '')
				addVertex('editors/images/rounded.gif', 40, 40, 'shape=ellipse')
			}
		}

		// double click - properties window TODO
		/*function showModalWindow (graph, title, content, width, height) {
			const background = document.createElement('div')
			background.style.position = 'absolute'
			background.style.left = '0px'
			background.style.top = '0px'
			background.style.right = '0px'
			background.style.bottom = '0px'
			background.style.background = 'black'
			mxUtils.setOpacity(background, 50)
			document.body.appendChild(background)

			if (mxClient.IS_IE) {
				new mxDivResizer(background)
			}

			const x = Math.max(0, document.body.scrollWidth / 2 - width / 2)
			const y = Math.max(10, (document.body.scrollHeight ||
				document.documentElement.scrollHeight) / 2 - height * 2 / 3)
			const wnd = new mxWindow(title, content, x, y, width, height, false, true)
			wnd.setClosable(true)

			// Fades the background out after after the window has been closed
			wnd.addListener(mxEvent.DESTROY, function (event) {
				graph.setEnabled(true)
				mxEffects.fadeOut(background, 50, true, 10, 30, true)
			})

			graph.setEnabled(false)
			graph.tooltipHandler.hide()
			wnd.setVisible(true)
		}*/

		// Creates the text field for the given property (in modal window)
		/*function createTextField (graph, form, cell, attribute) {
			const input = form.addText(attribute.nodeName + ':', attribute.nodeValue)

			const applyHandler = function () {
				const newValue = input.value || ''
				const oldValue = cell.getAttribute(attribute.nodeName, '')

				if (newValue !== oldValue) {
					graph.getModel().beginUpdate()
					try {
						const edit = new mxCellAttributeChange(cell, attribute.nodeName, newValue)
						graph.getModel().execute(edit)
					} finally {
						graph.getModel().endUpdate()
					}
				}
			}

			mxEvent.addListener(input, 'keypress', function (event) {
				// Needs to take shift into account for text areas
				if (event.key === 'Escape' && !mxEvent.isShiftDown(event)) {
					input.blur()
				}
			})

			if (mxClient.IS_IE) {
				mxEvent.addListener(input, 'focusout', applyHandler)
			} else {
				// Note: Known problem is the blurring of fields in Firefox by changing the selection,
				// in which case no event is fired in FF and the change is lost.
				// As a workaround you should use a local variable that stores the focused field and
				// invoke blur explicitly where we do the graph.focus above.
				mxEvent.addListener(input, 'blur', applyHandler)
			}
		}*/

		function addToolbarItem (graph, toolbar, w, h, style, image, xmlDocument) {
			// Function that is executed when the image is dropped on the graph.
			// The cell argument points to the cell under the mouse pointer if there is one.
			const funct = function (graph, event, cell, x, y) {
				graph.stopEditing(false)

				let vrtx
				if (style === 'shape=ellipse') {
					vrtx = xmlDocument.createElement('Variable')
					vrtx.setAttribute('name', 'var')
				} else {
					vrtx = xmlDocument.createElement('Operation')
					vrtx.setAttribute('name', 'op')
				}

				// Gets the default parent for inserting new cells.
				// This is normally the first child of the root (ie. layer 0).
				const parent = graph.getDefaultParent()

				var vertex = graph.insertVertex(parent, null, vrtx, x, y, w, h, style)

				/*const vertex = graph.getModel().cloneCell(prototype)
				let title
				if (prototype.style === 'shape=ellipse') {
					title = 'var'
				} else {
					title = 'op'
				}
				vertex.value = title
				vertex.geometry.x = x
				vertex.geometry.y = y

				graph.addCell(vertex)*/
				graph.setSelectionCell(vertex)
			}

			// Creates the image which is used as the drag icon (preview)
			const img = toolbar.addMode(null, image, function (event, cell) {
				const pt = this.graph.getPointForEvent(event)
				funct(graph, event, cell, pt.x, pt.y, xmlDocument)
			})

			// Disables dragging if element is disabled. - TODO, not working
			// This is a workaround for wrong event order in IE.
			// Following is a dummy listener that is invoked as the last listener in IE.
			mxEvent.addListener(img, 'mousedown', function (event) {
				// do nothing
			})
			// This listener is always called first before any other listener in all browsers.
			mxEvent.addListener(img, 'mousedown', function (event) {
				if (img.enabled === false) {
					mxEvent.consume(event)
				}
			})

			mxUtils.makeDraggable(img, graph, funct)

			return img
		}
	</script>

</head>

<!-- Calls the main function after the page has loaded. Container is dynamically created. -->
<body onload="main();"></body>
</html>