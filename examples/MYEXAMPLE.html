<!DOCTYPE html>
<!--suppress JSPotentiallyInvalidConstructorUsage -->
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Toolbar example for mxGraph</title>

	<!-- Sets the basepath for the library if not in same directory -->
	<script type="text/javascript">
		mxBasePath = '../src'
	</script>

	<!-- Loads and initializes the library -->
	<script type="text/javascript" src="../src/js/mxClient.js"></script>

	<!-- Example code -->
	<script type="text/javascript">
		var incoming = {}
		var outgoing = {}
		// Program starts here. Creates a sample graph in the DOM node with the specified ID.
		// This function is invoked from the onLoad event handler of the document (see below).
		function main (container, toolbar, sidebarContainer) {
			// Checks if browser is supported
			if (!mxClient.isBrowserSupported()) {
				// Displays an error message if the browser is not supported.
				mxUtils.error('Browser is not supported!', 200, false)
			} else {
				// Note that these XML nodes will be enclosing the mxCell nodes for the model cells in the output
				const xmlDocument = mxUtils.createXmlDocument()

				// creates new sidebar without event processing
				const sidebar = new mxToolbar(sidebarContainer)
				sidebar.enabled = false

				// Workaround for Internet Explorer ignoring certain styles
				if (mxClient.IS_QUIRKS) {
					document.body.style.overflow = 'hidden'
					new mxDivResizer(container)
					new mxDivResizer(toolbar)
					new mxDivResizer(sidebar)
				}

				// Graph event handler that creates new connections
				mxConnectionHandlerInsertEdge = mxConnectionHandler.prototype.insertEdge
				mxConnectionHandler.prototype.insertEdge = function (parent, id, value, source, target, style) {
					// parent	mxCell that specifies the parent of the new edge.
					// id	    Optional string that defines the Id of the new edge.
					// value	JavaScript object to be used as the user object.
					// 	source	mxCell that defines the source of the edge.
					// 	target	mxCell that defines the target of the edge.
					// 	style	Optional string that defines the cell style.
					//TODO
					//console.log('hi there ' + parent.getAttribute('name', 'parent') + ' '
					//	+ source.getAttribute('name', 'source') + ' ' + target.getAttribute('name', 'target'))
					// "parent opName varName

					//console.log('and there ' + parent.getId() + ' '	+ source.getId() + ' ' + target.getId())
					incoming[target.getId()][source.getId()] = true
					outgoing[source.getId()][target.getId()] = true
					//object[key] = true;
					//if (object.hasOwnProperty(key)) { ... }
					//delete object[key]

					return mxConnectionHandlerInsertEdge.apply(this, arguments)
				}

				// Creates the graph inside the given container.
				// The editor is used to create certain functionality for the graph, such as the rubberband selection,
				// but most parts of the UI are custom in this example.
				const editor = new mxEditor()
				const graph = editor.graph
				const model = graph.model
				model.isCreateIds() // Tell the model to manage cell ids for us

				const layout = new mxCompactTreeLayout(graph)
				layout.execute(graph.getDefaultParent())

				// Disables some global features
				graph.setConnectable(true)
				graph.setMultigraph(false)
				graph.setCellsDisconnectable(false)
				graph.setAllowDanglingEdges(false)

				// Sets the graph container
				editor.setGraphContainer(container)

				// Enables rubberband selection
				const rubberband = new mxRubberband(graph)

				// Removes cells when [DELETE] is pressed
				const keyHandler = new mxKeyHandler(graph)
				keyHandler.bindKey(46, function (event) {
					if (graph.isEnabled()) {
						graph.removeCells()
					}
				})

				// Overrides method to provide a cell label in the display
				graph.convertValueToString = function (cell) {
					if (mxUtils.isNode(cell.value)) {
						//if (cell.value.nodeName === 'Variable')
						return cell.getAttribute('name', '')
					}
				}

				// Overrides method to store a cell label in the model
				const cellLabelChanged = graph.cellLabelChanged
				graph.cellLabelChanged = function (cell, newValue, autoSize) {
					if (mxUtils.isNode(cell.value)) {
						//if (cell.value.nodeName === 'Variable')
						// Clones the value for correct undo/redo
						const elt = cell.value.cloneNode(true)
						elt.setAttribute('name', newValue)
						newValue = elt
					}
					cellLabelChanged.apply(this, arguments)
				}

				// Installs a popupmenu handler using local function (see below)
				graph.popupMenuHandler.factoryMethod = function (menu, cell, event) {
					return createPopupMenu(graph, menu, cell, event)
				}

				// Shows a "modal" window when double clicking a vertex.
				/*graph.dblClick = function (event, cell) {
					// Do not fire a DOUBLE_CLICK event here as mxEditor will
					// consume the event and start the in-place editor.
					if (this.isEnabled() &&	!mxEvent.isConsumed(event) &&
						cell != null &&	this.isCellEditable(cell)) {
						if (this.model.isEdge(cell)) {
							this.startEditingAtCell(cell)
						} else {
							var content = document.createElement('div')

							// Creates the form from the attributes of the user object
							var form = new mxForm()
							var attrs = cell.value.attributes
							for (var i = 0; i < attrs.length; i++) {
								createTextField(graph, form, cell, attrs[i])
							}
							content.appendChild(form.getTable())
							showModalWindow(this, 'Properties', content, 400, 300)
						}
					}

					// Disables any default behaviour for the double click
					mxEvent.consume(event)
				}*/

				// Add toolbar items
				addToolbarButton(editor, toolbar, 'generateCode', 'Generate code', 'images/export1.png')

				editor.addAction('generateCode', function (editor, cell) {
					const code = generateCode(graph)

					if (code.length > 0) {
						var textarea = document.createElement('textarea')
						textarea.style.width = '400px'
						textarea.style.height = '400px'

						textarea.value = code
						showModalWindow(graph, 'LuNA code', textarea, 410, 440)
					} else {
						mxUtils.alert('No operations on canvas')
					}
				})

				// Add sidebar items
				const addVertex = function (icon, w, h, style) {
					//const vertex = new mxCell(null, new mxGeometry(0, 0, w, h), style)
					//vertex.setVertex(true)
					const img = addSidebarItem(graph, sidebar, w, h, style, icon, xmlDocument)
					img.enabled = true

					graph.getSelectionModel().addListener(mxEvent.CHANGE, function () {
						const tmp = graph.isSelectionEmpty()
						mxUtils.setOpacity(img, (tmp) ? 100 : 20)
						img.enabled = tmp
					})
				}

				addVertex('editors/images/rectangle.gif', 100, 40, '')
				addVertex('editors/images/rounded.gif', 40, 40, 'shape=ellipse')
			}
		}

		function showModalWindow (graph, title, content, width, height) {
			const background = document.createElement('div')
			background.style.position = 'absolute'
			background.style.left = '0px'
			background.style.top = '0px'
			background.style.right = '0px'
			background.style.bottom = '0px'
			background.style.background = 'black'
			mxUtils.setOpacity(background, 50)
			document.body.appendChild(background)

			if (mxClient.IS_IE) {
				new mxDivResizer(background)
			}

			const x = Math.max(0, document.body.scrollWidth / 2 - width / 2)
			const y = Math.max(10, (document.body.scrollHeight ||
				document.documentElement.scrollHeight) / 2 - height * 2 / 3)
			const wnd = new mxWindow(title, content, x, y, width, height, false, true)
			wnd.setClosable(true)

			// Fades the background out after after the window has been closed
			wnd.addListener(mxEvent.DESTROY, function (event) {
				graph.setEnabled(true)
				mxEffects.fadeOut(background, 50, true, 10, 30, true)
			})

			graph.setEnabled(false)
			graph.tooltipHandler.hide()
			wnd.setVisible(true)
			return wnd
		}

		// Creates the text field for the given property (in modal window)
		/*function createTextField (graph, form, cell, attribute) {
			const input = form.addText(attribute.nodeName + ':', attribute.nodeValue)

			const applyHandler = function () {
				const newValue = input.value || ''
				const oldValue = cell.getAttribute(attribute.nodeName, '')

				if (newValue !== oldValue) {
					graph.getModel().beginUpdate()
					try {
						const edit = new mxCellAttributeChange(cell, attribute.nodeName, newValue)
						graph.getModel().execute(edit)
					} finally {
						graph.getModel().endUpdate()
					}
				}
			}

			mxEvent.addListener(input, 'keypress', function (event) {
				// Needs to take shift into account for text areas
				if (event.key === 'Escape' && !mxEvent.isShiftDown(event)) {
					input.blur()
				}
			})

			if (mxClient.IS_IE) {
				mxEvent.addListener(input, 'focusout', applyHandler)
			} else {
				// Note: Known problem is the blurring of fields in Firefox by changing the selection,
				// in which case no event is fired in FF and the change is lost.
				// As a workaround you should use a local variable that stores the focused field and
				// invoke blur explicitly where we do the graph.focus above.
				mxEvent.addListener(input, 'blur', applyHandler)
			}
		}*/

		function addToolbarButton (editor, toolbar, action, label, image, isTransparent) {
			var button = document.createElement('button')
			button.style.fontSize = '10'
			if (image != null) {
				var img = document.createElement('img')
				img.setAttribute('src', image)
				img.style.width = '16px'
				img.style.height = '16px'
				img.style.verticalAlign = 'middle'
				img.style.marginRight = '2px'
				button.appendChild(img)
			}
			if (isTransparent) {
				button.style.background = 'transparent'
				button.style.color = '#FFFFFF'
				button.style.border = 'none'
			}
			mxEvent.addListener(button, 'click', function (evt) {
				editor.execute(action)
			})
			mxUtils.write(button, label)
			toolbar.appendChild(button)
		}

		function addSidebarItem (graph, sidebar, w, h, style, image, xmlDocument) {
			// Function that is executed when the image is dropped on the graph.
			// The cell argument points to the cell under the mouse pointer if there is one.
			const funct = function (graph, event, cell, x, y) {
				graph.stopEditing(false)

				let vrtx
				if (style === 'shape=ellipse') {
					vrtx = xmlDocument.createElement('Variable')
					vrtx.setAttribute('name', 'var')
					vrtx.setAttribute('type', 'var')
				} else {
					vrtx = xmlDocument.createElement('Operation')
					vrtx.setAttribute('name', 'op')
					vrtx.setAttribute('type', 'op')
				}

				// Gets the default parent for inserting new cells.
				// This is normally the first child of the root (ie. layer 0).
				const parent = graph.getDefaultParent()
				const model = graph.getModel()

				model.beginUpdate()
				let vertex
				try {
					vertex = graph.insertVertex(parent, null, vrtx, x, y, w, h, style)
					incoming[vertex.getId()] = {}
					outgoing[vertex.getId()] = {}
				} finally {
					model.endUpdate()
				}

				graph.setSelectionCell(vertex)
			}

			// Creates the image which is used as the drag icon (preview)
			const img = sidebar.addMode(null, image, function (event, cell) {
				const pt = this.graph.getPointForEvent(event)
				funct(graph, event, cell, pt.x, pt.y, xmlDocument)
			})

			// Disables dragging if element is disabled. - TODO
			// This is a workaround for wrong event order in IE.
			// Following is a dummy listener that is invoked as the last listener in IE.
			mxEvent.addListener(img, 'mousedown', function (event) {
				// do nothing
			})
			// This listener is always called first before any other listener in all browsers.
			mxEvent.addListener(img, 'mousedown', function (event) {
				if (img.enabled === false) {
					mxEvent.consume(event)
				}
			})

			mxUtils.makeDraggable(img, graph, funct)

			return img
		}

		function generateCode (graph) {
			const code = []
			const df = ['df ']
			const parent = graph.getDefaultParent()

			for (let i = 0; i < graph.model.getChildCount(parent); i++) {
				const child = graph.model.getChildAt(parent, i)
				if (!graph.model.isEdge(child)) {
					if (child.getAttribute('type', '') === 'var') {
						df.push(child.getAttribute('name', '') + ', ')
					} else if (child.getAttribute('type', '') === 'op') {
						code.push(child.getAttribute('name', '') + '(#in ')
						const map1 = incoming[child.getId()]
						for (const key in map1) {
							if (map1.hasOwnProperty(key)) {
								const value = map1[key]
								if (value) {
									const tempCell = graph.model.getCell(key)
									code.push(tempCell.getAttribute('name', '') + ', ')
								}
							}
						}
						code.push('#out ')
						const map2 = outgoing[child.getId()]
						for (const key in map2) {
							if (map2.hasOwnProperty(key)) {
								const value = map2[key]
								if (value) {
									const tempCell = graph.model.getCell(key)
									code.push(tempCell.getAttribute('name', '') + ', ')
								}
							}
						}
						code.push(');\n')
					}
				} else {
					//console.log('edge')
				}
			}
			df.push(';\n')
			return df.join('') + code.join('')
		}

		// Function to create the entries in the popupmenu
		function createPopupMenu (graph, menu, cell, event) {
			if (cell != null) {
				menu.addItem('Cell Item', 'editors/images/image.gif', function () {
					mxUtils.alert('MenuItem1')
				})
			} else {
				menu.addItem('No-Cell Item', 'editors/images/image.gif', function () {
					mxUtils.alert('MenuItem2')
				})
			}
			menu.addSeparator()
			menu.addItem('MenuItem3', '../src/images/warning.gif', function () {
				mxUtils.alert('MenuItem3: ' + graph.getSelectionCount() + ' selected')
			})
		}

	</script>

</head>

<!-- Calls the main function after the page has loaded. Container is dynamically created. -->
<body onload="main(document.getElementById('graphContainer'),
			document.getElementById('toolbarContainer'),
			document.getElementById('sidebarContainer'));"></body>

<!-- Creates a container for the graph -->
<div id="graphContainer"
     style="position:absolute;overflow:hidden;top:36px;left:24px;bottom:0px;right:0px;background-image:url('editors/images/grid.gif');">
</div>

<!-- Creates a container for the toolbar -->
<div id="toolbarContainer"
     style="position:absolute;white-space:nowrap;overflow:hidden;top:0px;left:0px;max-height:24px;height:36px;right:0px;padding:6px;background-image:url('images/toolbar_bg.gif');">
</div>

<!-- Creates a container for the sidebar -->
<div id="sidebarContainer"
     style="position:absolute;overflow:hidden;top:36px;left:0px;bottom:0px;width:24px;padding:2px;">
</div>

</html>